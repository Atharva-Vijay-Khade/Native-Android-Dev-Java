

Android Development for Beginners - Full Course 
FreeCodeCamp.org 

Notes

Activity
    Our Apps has many parts, we can think of an activity as a page for that part
    This definition is not 100% correct, activity more in detailed studied later
    as the course goes ahead

.xml file and activity file 
    .xml file is the file where we specify the layout for the App
    activity file is the file which tells what happens if there's an 
    action on the .xml's layout

build window
    here we can see the progress/phase of the app as it grows
    from here we can locate problems in our app

resources folder {res}
    it has resources like app logo, app images all static components are placed 
    here

manifest file
    specifies general properties for the application
    ie: name and logo of the application info is placed here 
    other properties and features of the app are placed here

gradle files 
    when we want to download the app from the playstore
    then only one apk file is downloaded for our app
    how to generate that apk file, for that this gradle tool is used 
    Gradle is the build tool that will combine all the gradle files 
    and will create an apk file, for testing on emulator or exporting it 
    on playstore, Also we use it to use other people's code, say we want code for 
    youtube file, then we add it's dependencies in the build.gradle file, thus gradle
    will download the code for youtube player and genearte the code for it
    so that we can use it


TODO window
    the things that we have to implement in the app in future and we don't want 
    to forget so we can add a todo
    // TODO: text
    we can find them in project window and seperately in todo window

Logcat 
    helpful in debugging our application

# if we get some warnings or errors in running application then we can 
# select the build option and select Make Project
# Closing and reopening the application will also work
# we can also go to files and invalidate the cache and restart to solve such issues

Profiler
    go to view-tool window-Profiler
    This is the tool which shows how our app uses resources 
    ie: network, cpu, ram etc 

.xml file {contents}
    it has two views, white and blue print views of application
    white one is called DESIGN view
    If we have an invisible component in layout of our app
    then we can keep track of it using blue print view it's not visible 
    in design view

Pallet view in xml
    here we can add ui elements to our app, each element has attributes 
    which we can add, and id associated with it, with which we can control this 
    element form the activity file,
    
XML views 
    it has two types of views
        1] Design view where theres' gui basesd id and attirbute selection
        2] Text view here we can add by typing values to each attirbute
    xml is a markup language
    markup language are just for defining some elements that user is going to see 
    ie: button and text etc
    -> we can add button with gui based selection
    -> Or we can type in xml markup language to add the button
    # we cannot use space giving id to components 
    # also we cannot use #,$ etc characters     
    -> Conventions = first character lower cases and after the first word
    we type in capital letters after each word

Giving constraints to the components in xml
    It's important to specify xml constraints, if we don't specify them
    then the component location won't be fixed during run time, mainly it goes 
    to 0th index on the screen {at the top}
    This is because we are using .ConstraintLayout


Inside Activity File 
    The onCreate function is the starting point of our application
    whatever is written in the curly braces in the onCreate function
    will be executed first
    The setContentView() function is the function which connects our 
    .xml file with the activity file, this shows that these two files are somehow
    related to each other

Using TextView
    In java we have classes that are similar to the ui components in the 
    xml file, these classes can be used to display the ui components

way -> 
    First Create a TextView object
        TextView name_obj;
    Now find the Ui component from the xml file and connect it with This object
        TextView name_obj = findViewById(R.id.NAME_OF_ID_OF_UI_IN_LAYOUT_FILE);
        R class in java android, stands for resources, by this we can have
        acces to all static resources in java, like ui components from the xml file

        now we can say  
            name_obj.setText("new text that we want");

        this will change the text and display what we want 

    Now we want to change this text when we press a button 
    thus we do this using eventListner
    We firs go to xml file and select appropriate ui component
    then we add an onClick into it and specify the method name there
    this method name is created outside the scope of onCreate 
    and inside MainActivity, and we specify what happens after clicking this 
    button here in this method

    Now we want to take the text from the user and show it up on the screen 
    for taking the text from the user we use EditText
    way
        EditText edtText = findViewById(R.id.editTextTextPersonName);
        edtText.getText().toString();   

    VVVVVIMP 
        Scope of the editText is only in the onCrete function
        we cannot use it outside this function
        ie: we cannot define it in onCreate and use it outside it
        so to solve this we do declaration and definition both inside in the 
        function outside the onCreate
    way- Function outside onCreate
        public void changeText(View view) {
        TextView txtView = findViewById(R.id.textView);
        EditText edtText = findViewById(R.id.editTextTextPersonName);
        txtView.setText("hello " + edtText.getText().toString());
    }

    
__________________________JAVA_______________________________

java ide's - intelliJ, Ecplise

Android Studio is built upon the intelliJ IDE, So they both look very similar

-> Printing Statement in java

System.out.println("asijioajsdfoij"); - prints the string and inserts a new line
System.out.print("hioasdfhoi"); - prints and no new line, continous printing

comments //,
         // TODO Do something -> addeds the todos' and useful in Development

variables
    storing data in java application
    int number = 5;    // small integers 2^31
    System.out.println(number);   
    long myLong = 5; // stores large numbers 2^63
    
    #imp for floating numbers we write
    float myFloat = (float) 4.5;
    casting is required 

    double myDouble = 4.5; // stores larger values than float

    char myChar = 'c';
    we can also store special characters in myChar by using special unicodes

    String name = "Meisam";  // String is a class but upper all are primitive data types

    boolean myBoolean = false; // takes only true of false values

Operators in Java

    Arithmetic Operators

        int a = 6;
        int b = 2;
        int answer = a + b;
        int answer2 = a - b;
        int answer3 = a / b;  // b!= 0 handle this exception, or application will crash
        int answer4 = a * b;
        int answer5 = a % b;

        double answer = (double) a/b; // integer division 
        // but this will take a/b exact value as if a = 5 and b = 2
        // answer will be 2.5
        // this is different from C/C++

        String firstName = "Hello";
        String lastName = "Bye";
        we can use + operator to concatinate the above two strings
        String fullName = firstName + lastName;
        System.out.println(fullName);
        
        int a = 5;
        a = a + 2;
        or we could say
        a+=2;
        both are same

        for increment 
        a++;
        or 
        a = a + 1;
        same goes for minus

        ShortHand Notations
        +=
        -=
        /=
        *=
        %= 
    
    Relational Operators in Java

        GreaterThan > /LessThan < operator
            boolean answer = a>b;
            boolean answer2 = a<b;  
        Euquality Operators
            boolean answer = a==b;
        Comparison Operators
            boolean answer = a>=b;
            boolean answer = a<=b;
            boolean answer = a!=b;
    
    Logical Operators in Java   

        boolean answer = a==5 || b==2; // OR operator
        boolean answer = a==5&&b==2; // And Operator

    Conditional Statements

        if(a>3)  {
            System.out.println("a is greater than 3");
        }

        System.out.println("continues here..");
        
        if(condition){
            //code if condition true
        }
        else {
            // if condition is false
        }

        we can also wirte 
        if(!condition) {
            //if condition not true
        }
        else {
            // if condition is true
        }

        we can have else if 

        if(a>3){
            //
        }
        else if(a<0){

        }
        else if(a==0){

        }
        else{

        }

        switch(a){
            case 1:
                System.out.println("A is one");
                break;
            case 2:
                //
                break;
            case 3:
                //
                break;
            default:
                //
                break;
        }

        loops in java

        1] for loops    
            int a = 10;
            //use 10 or a in for loop
            for(int i=0;i<10;i++){
                System.out.println(i);
            }

        2] while loop   
            while(a<10){  // infinite loop
                //
            }
            // so change value of a in the while loop

            break; 
            and continue; 
            in the loop

            int a = 5;
            while(a<10){
                a++;
                if(a==8)
                    continue;
                System.out.print(a);
            }

        3] Do while loop
            do {
                System.out.print("Hello");
            }while(a<5);

        To take input 

        System.out.println("Please enter number");
        Scanner scanner = new scanner(System.in);
        int answer = scanner.nextInt();
        System.out.print("Ansewer was : " + answer);
        
        String name = scanner.next();
        // to take name which is string

        Generating random number 

        Random random = new Random(); // generates random number from 0 to 19 both inclusive
        int number = random.nextInt(bound : 20);

    Arrays in java

        String students[] = new Strings(5);
        students[0] = "ben";
        students[1] = "ten";
        students[2] = "eleven";
        ... 

        String employees[] = {"ben","tom","ken"};

        int numbers[] = {1,2,3,4,5,6};

        for(int i=0;i<numbers.length;i++)
            System.out.println(numbers[i]);

        if we want dynamic sized arrays then we can't use string array
        ie : we can not add 5 th element in string array of size 4

        String names[] = {"hello","bye","ken","ten"};

        String contacts[] = {"1","2","3","4"};

        for(int i=0;i<names.length;i++){
            System.out.println(names[i]); 
        }

        System.out.println("Please Enter a name");
        Scanner scanner = new Scanner(System.in);
        String name = scanner.next();
        for(int i=0;i<names.length;i++){
            if(name == names[i]){ // this is incorrect way to compare in java
                                  // as name is a reference variable 
            }                     // so it can't be compared with string as it points to a string and is not actually a string

            // correct method 
            if(name.equals(names[i])){ // .equals method string object
                //
            }
    
        }


___________________________________________________________________________________________________________________________________________________________________________________________
    
Object Oriented Programming in JAVA - VVVVVIMP

-> we have a main class, which has the main function 
-> this is the starting point of the application
-> we can now create packages and create classes which we can instantiate in this function
-> access specifiers are very essential to be known

-> once we create a class in other package, and create class there
then we can have get and set methods there manually added by us to update the variables

-> but java allows us to have getters and setters which will automatically come once we tell the ide
these are used to initialized the variables used in classes or change variable values or get the values

-> one of the best use case of getters and setters is encapsulation, data hiding 
-> Or we can have a validation using getters and setters for data fields

This is one way to initialize fields in java
other best way is using constructor

visibility of constructor also matters, as other package classes can also access it 

constructor overloading is allowed in java constructors => also refered to one type of polymorphism in java

-> INHERITANCE {IMP}
    Allows reusability of code
    super mehthod is important in initialization of parent class fields
    super is used in both constructors and the functions which are overrided
    if we have a base class and it has a method say fun(int a)
    then we can have same method in sub class fun(int a) which can 
    perform different functionality, this is also example of polymorphism in java 
    here super is used to initialize field of parent fun(int a) so by default that will also be 
    called if super is there, if we remove super then dominantly, the function fun(int a) of base 
    class is called and not both

-> Composition of differnet objects in a class 

ie : 

package p1;                                                 

public class Engine {
    //fields 
    public Engine(fields) {
        //constructor
    }
}

now in other package, parent package of p1 mainly

package p2;

public class Car {
    //fields normal
    private Engine engine;
    Car(fields,Engine engine){
        //other fields
        this.engine = engine;
    }
}

now we can use this class engine inside class Car, this is composition of objects in other class

hovere comments in java are mainly due to 
/**                          this is how when we hover and press ctrl we see comments of whats there in this field
 * comments 
 *
 *@return 
 */ 

 if we want to instantiate objects for a class in future then we can presently reference to that 
 object as null

ie : Engine engine = null;
     here if we try to call method using engine reference
     then it will give null pointer exception which will crash our Program
     # this is a runtime error not compile time error

     this is handeled using 

     if(engine != null){
        // call method on that 
     }
     else {
        //print engine being null message
     }

=> FINAL keyword

    int a = 5;
    a = a+1;
    this is valid 

    but,
    final int a = 5;
    a = a+1;
    this is not valid 
    as variables declared as final can't be 
    reassigned to other values, this will give error 

    final Engine engine = new Engine(rpm:9000,name:"renault");
    engine = new Engine(rpm:1000,name:"renault");
    this will give error as we are changing the entire instance
    but we can change it's properties
    ie: 
    engine.setRpm(6000);//this is valid for final preceded variables


____________Collections in java______________ 

String names[] = new Strings[5];
String names[] = {"hello","bye"};

size is immutable, meaning size cannot be changed 
so we cannot say names[2] in string of size 2
exception generated array out of bounds error

so if we want to add new element in array then 
we have to start all over again creating new array 
and copy pasting all elements back in new array and 
then add the new element in array

-> this is time consuming and resource consuming process

Thus we use COLLECTIONS IN JAVA


1] ArrayList

    ->ArrayList<String> names = new ArrayList<>();
    -one way to define array list of strings in java
    
    ->List<String> students = new ArrayList<>();    
    -other way to define array list in java
method = names.add("Meisam");
now size is mutable, that means we can add as many strings 
as we can 

method = names.get(index); to retrive element at that index
       = names.size();
       = names.clear();
       = names.remove("Meisam"); // remove entry Meisam from the array list 
       -> it's like a vector in C++
       = names.contains("string");
       = names.isEmpty();
       = names.indexOf("req String"); // prints index of the given string in array list, if no such elements -1 is returned

> ArrayList can be of primitive data types 
> ie: ArrayList<int> i = new ArrayList<>();
  this is not valid in java
  we cannot have a list of primitive data types
  thus we equivalent, java class, ie: Integer for int
  ArrayList<Integer> names = new ArrayList<>();
  ArrayList<Double> names = "";
  same for other data types

>names.sort(compartor);

// Printing the elements in arraylist using index in java
for(int i=0;i<names.size;i++){
    System.out.println(names.get(i));
}

Colletion MAP in java

Map<key,value> name;

ie: Map<String,String> contacts = new Map;
    this is one way, with lots of functions coming up

    better way
    Map<String,String> contacts = new HashMap<>();
    contacts.put("Meisam","Meisam@meicode.org");
    contacts.put("Brad","Brad@gmail.com");
    System.out.println("contacts.get("Meisam"));
    -> gets the email address of Meisam

    For maps also, Map<int,int> is not valid 
    for primitive data types we have to use Classes 
    for these primitive data types

Adding User defined datatypes into java collections 

public class student {
    private String name;
    private String id;
    constructor();
    setter and getter;
}

public class Main {
    public static void main(String args[]){
        ArrayList<Student> students = new ArrayList<>();
        students.add(new Student("atharva","7"));
    }
}

For each loop in java

for(Student s : students) { // s is object of class Student, student is the list on which we iterate    
    System.out.println(s.getName());
}


_____________________Static KeyWord in __________________________


public class TestClass {
    public static String name; // when method or varible are declared as static then they belong to object/class it self and not to the instances of that object/class 
    public int age;
    public String jskinColor;
    TestClass(int age,String skinColor){
        this.age = age;
        this.skingColor = skinColor;
    }
    // there is no constructor field for the static variable in the class
    // but it does has getter and setters 

}

in main{
    TestClass = new TestClass(age:25,skinColor:"white");
    testClass.setName("Meisam"); // this is ok but we can set value for name even if we don't have the object of that class
    TestClass.name = "Meisam";

}

all instances of the class will have same name field
if the name filed is declared as static

methods can also be static

Why static members and methods?

Advantages

-> if we want a same field for all instances
 ie: if company has employee data, then all have same field as 
     company name so, that can be made as static

-> We can manage memory well and avoid extra space wastages 

Disadvantage

-> Non Static field cannot be referenced from a static context
meaning-> if we are in a method which is declared as static then we cannot 
access any non-static field of the class from that method

______________Inner Classes in Java___________________

public class TestClass {

    private int age;
    private String color;

    private class TestInnerClass {
        private String name;

        public TestInnerClass(String name){
            this.name = name;
        }

        private void printAge(){
            System.out.println("Age:"+age); // this is totally valid 
        }

    }
}

// Uses -> we can have access of private variables also of the parent class in the inner classes
        -> readability of the code increases 
        -> we can have private access specifier for a class 
        -> we can also have static classes
        private static class TestInnerClass {

        }
        -> inner classes are useful in async codes 


_____________Interfaces and Abstract Classes in Java_____________________


Interface are like a contract between two part of our application

public interface CarInterface {
    public void printName(String name); // this is abstract method, interface can only have abstract methods, we cannot define it's body in interface itself
    // public modifier is redundant{not necessary}, all methods are by default public, it can't be private or protected abstract methods in interface
    void start();
    void move(int speed);

}

// now using this interface 

public class ElectricCar implements CarInterface {  
    
    private String name;
    
    // we need to implement all the methods {abstrace} of the interface
    @overrided
    public void start(){
        System.out.println("electricity flow stated");
    }
    @overrided
    public void move(int speed) {
        // function
    }
}

in main {

    CarInterface carInterface = new ElectricCar(); // this is validation
    // we are assigning car interface to ElectricCar instance which is totally valid

    CarInterface.speed(60);

}

One of the method of declaring ArrayList 
was interface method 

List<String> name = new ArrayList<>();

this List<E> is a interface, E means it accepts any argument

# Contract is that, the class which implements the interface should have 
  the methods given in the interface details

Uses of Interface 
    -> We can have multiple inheritance in java
    -> CallBack interfaces, use full when we use event listners, and connection in between two threads
    -> we can implement multiple interface for a class, that's multiple inheritance


Abstract Classes in Java

public abstract class TestAbstractClass {
    //has abstract methods
    public abstract void printName(String name);

    public void print(String text){
        //working this is valid in this case
    }

}

// difference in between interface and abstract class 

public class TestClass extends TestAbstractClass {

}
but for interface we use implements 

-> Abstract class does not support multiple inheritance
-> Inside abstract we can have non-abstract methods


public TestClass extends TestAbstractClass {
  
    @override 
    public void printName(String name) {   
        // define method here
    }

}

in main {
      TestAbstractClass testAbstractClass = new TestClass();
      testAbstractClass.printName("hello");
}

// Which one to select, interface or abstract class is very imp, for that go throught the docs on oracle on java
interface and abstract classes


____________Concurrency in java______________

Concurrency meaning -> Doing things at same time in Programming

ie : multithreading 

Thread is unit of execution in cpu or processor
threads are programs are handeled by the cpu
there is main thread in our application, by default
also called as UI thread, if we want other background thread
we can crate other thread

Thread thread = new Thread(new Runnable(){
    @override 
    public void run() {
        System.out.println("hello from anther thread");
    }
});
thread.start();    // run method of Runnable() class tells what the thread does

this is one way, we also have other way of defining a thread

// Sleeping a thread

Thread.sleep(1000); time in milliseconds
// this Thread refer to that thread in which we are currently in 

UI thread -> has as many worker thread as we can

the main thread is the UI thread 


// Exceptions in java

1] Generic Exceptions
try{
    //{no need of throwing, if it occur it is auto thrown}
}
catch(Exception e){
    //handel
}

2] Arithmetic Exceptions 
try{
    a= a/b; //if b==0 it throws arithmetic exception
}
catch(ArithmeticException e){
    // handel
}

3] Interrupted Exceptions 
try{
    Thread.sleep(1000);
}
catch(InterruptedException e){  // occur when current thread is interrupted, ie: when a thread is running and at the same a phone call comes then we need to handel it other wise it will crash the application
    //handel
}

4] Null pointer exception
String name = null;
try{
    null.length;
}
catch(NullPointerException e){
    //
}

// useful method for debuggin 

catch(Exception e){
    e.printStackStrace(); // print something in console for help in debugging
}







______________________Singleton Pattern___________________________

// we use it when we know that we have only one instance of a class 

// ie : during using DataBase

public class Database {

    private String name;

    private static Database instance;

    public static Database getInstance(String name) {
        if(null == instance) {
            instance = new Database("name");
            return instance;
        }
        else{
            return instance;
        }
    }

    constructor();
    getter and setter;


}

// whenever in the main or in other class we say

Database database = Database.getInstance("name");
then only one instance will be maintained, new instances won't be made

thus only one instance of the class is created

but we can still instansiate the database class

so solution is that we declare the constructor of the database as private

but still there is a problem, multiple threads can create multiple instances
of the same class asynchrounously, so for that we use 

public static synchronized Database getInstance(String name) {
    //
}

synchronized key word-> now only one thread can create the instance of the class
=> This is singleton pattern in java

// toString() method is present for every class's object,
we can override it inside the class to get result that we want

// Complete Java Challenge part 1

idea->  

DataBase {  //using singleton pattern

    Map<String,Object> {
        user1: Oject(arraylistofContactNumbers,messageList);
        user2: same;
        user3: same;
        user4: same;
        ...
    }

}

Object used above will be {
    arraylist;//for numbers;
    arrylist0;//for messages;
}

________________________________________________USER INTERFACE______________________________________________


Firstly we are using relative layout in xml file 

<TextView 
    fields..
    ie:center_Horizontal="true"
    ie:centerInParent="true"
    ie:testSize:"20sp"
    ie:textStyle="bold|italic"
    textColor="@color/colorAccent"
    we can also pass it from color picker
    ie:id="@+id/txtWelcome"// should be unique
    
    <Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" // this is useful that specifing values, because it will be same in all mobile devices
        android:text="Say hello"
        android:layout_below:"@+id/txtWelcome"
        android:layout_centerHorizontal="true"
        android:background="@color/colorPrimary"
        android:onClick="onHelloBtnClick" -> make this function in main activity
    />
/>

public void onHelloBtnClick(View view) {

    TextView txtView = findViewById(R.id.txtWelcome);
    txtView.setText("hello again");

}


--------
Another way

<Button
    wrap_content
    text="say Hello"
    layout_centerInParent="true"
    id="@+id/btnHello"
    onClick=""
/>

in onCreate 

# here we need to use interface View.onClickListener

Button btnHello = findViewById(R.id.btnHello);
btnHello.setOnClickListener(new View.onClickListener(){
    @override 
    public void onClick(View v){
        System.out.println("hello");
    }
});

flow-> 

first we have a button 
btnHello = findViewById(R.id.btnHello);
//now setup an onClickListner for that button
btnHello.onClickListner();
// now pass interface into it 

btnHello.onClickListner(new View.onClickListener(){
    //now override onClick function for that interface
    public void onClickView(View v){
        System.out.println("hello");
    }
});

Another way

public class MainActiivity extends AppCompatActivity implements View.onClickListener {


    @override
    public void onClick(View v){
        switch(v.getId()){
            case R.id.btnHello:
            System.out.println("hello");
            break;
            default:
                break;
        }
    }

    //now in onCreate
    Button btnHello = findViewById(R.id.btnHello);
    btnHello.setOnClickListener(this);

}

Flow-> first of all in the onCreate we setup a onClickListener for this button
then when any component on UI is clicked then onClick method is triggered
according to switch case and id matching the case is selected

We can use Toast.makeText(context:this, text:"Hello button clicked",Toast.LENGTH_SHORT).show();
it shows up a pop up message

As of now we refer context to the current activity that we are on

Actually a Button is a View, every UI element is a View
thus we specify View inside onClick function

# check on it's implementation

we can add multiple such UI components and pass them to onClick 
or implement it using View.on_____Listener



